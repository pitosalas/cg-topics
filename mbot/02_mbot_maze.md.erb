---
title: "Project: mBot Maze"
desc: Introducing real world issues in driving a robot
---
## Intro
In this project your goal is to write software for the mBot robot and get it to drive in a controlled manner through a maze.

## Learning Objectives
* Basics of arduino robotics
* Write code for arduino, debug it, deploy it
* Examine some Maze solving algorithms
* Learn [PID algorithms](http://www.robotshop.com/letsmakerobots/pid-control), understand how they work, and implement one.

## Further details
* Given an mBot, you just have to figure out how to write code for it and it's arduino processor. You will do some basic web research and reading to accomplish this

* You can create whatever initial conditions you want within these constraints. The robot is placed on the floor, indoors, no closer than 2 meters from any wall. It independently begins driving in any direction, for 1meter, makes 4 90 degree turns, and tries to arrive at the same spot. There will be no obstacles.
* You may use whatever sensors are on the mBot or add any sensors you can find if you think that will help. You will have a $25 budget if you need it.

## Roadmap
**Step 1:** Using books create about a 100cm long road, with about 20 cm between walls formed by blocks

**Step 2:** Write a simple program to simply show the mBot driving forward and backward under control of your program, for a short distance and then back. You can use the "Block interace" for the mBot to play with. But from this point on you will have to be writing C++. Dont worry about learning C++, it is similar enough to Java for our purposes. We will help you with any differences.

**Step 3:** Place the robot at one end of the road, and your goal is to have it run to the other end of the road. This is not simple. You need to use the sensors (forward, left, right) to detect the distance to an onbstacle in each direction. Note that the sensors don't give the same answer but will sometime throw in some noisy data. You need to keep measuring the distance to the wall on the left and the right and try to keep the robot near the center. Investigate and implement a [PID algorithm](http://www.robotshop.com/letsmakerobots/pid-control), which tells you how to average and integrate the distance info to help the route not to be too jittery. It's ok if the robot moves quite slowly.

<%= callout("Clean Code"," Look over your code so far. Clean it up so it's not a big ugly mess of if then else's. Start thinking about good program design. Also start a Github repo for your program") %>

**Step 4:** Extend your road to have a 90 degree turn in it. Now improve your algorithm to detect the corner and make a clear turn while staying near the middle. You can detect the corner because the distance to the forward obsacle goes below a certain threshold, and at the same time the distance to one of the sides sudddenly becomes very large. This tells you you are at a corner.

**Step 5:** Now handle a dead end. If there is no distance in front, or left or right, then you are at a dead end. You need to rotate 180 degrees and head back in the direction you came.

**Step 6:** You have all the building blocks to have your mBot drive a maze. Create a more complicated maze, with one entrance and one exit. Update your software to traverse the maze and find its way from the start to the end. The actual Maze algorithm [can be any of a few options](https://en.wikipedia.org/wiki/Maze_solving_algorithm), but choose a really simple one to start. The hardest part will be keeping the robot moving and not craashing into walls etc!

**Step 7:** Depending on your success so far, now move to a line-following algorithm. Invent a way to mark off a maze, with forks and dead ends, with black tape or a marker on the surface. There are several ways to do this. Now, write a new program to run that maze, this time, instead of sensing the walls, following the lines on the surface.

## Notes
* For extra credit, make your robot detect cycles. Detecting cycles is not too hard. You can count the number of left and right turns to detect a "circle" but it would fail in the case of a spiral. There are some gaps in that heuristic, can you tell what they are?

## Lab Notebook
* Record your experiments in your lab notebook
