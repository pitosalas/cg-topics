---
title: ROS Best Practices and Patterns
---
:slide_bigtitle ROS Best Practices and Patterns

:h3 Python 

* We use ROS1 Noetic which requires Python 3.x
* You can choose to use classes or just top level functions
* If you find yourself using `global` often, that's a code smell and a hint that you should be using classes
* Other code smells to watch out for are: Functions of more than 20 or so lines, and classes of more than 100 or so lines, 

:h3 ROS Nodes, Topics, Messages

* There’s rarely a need to design a custom message (.msg) If you need one it’s ok but you should try and avoid it if possible.
* As a general rule if you can organize your functionality into multiple separate ROS nodes you will get better modularity and reusability.
* Each node should be in its own file.
* As a general rule you can get nicer ROS code if you break the functionality into python classes and in separate files (packages)
* This works especially well if you can identify bits functionality that may be reused in other applications
* Don’t assume that /scan topic’s LaserScan message has 360 items in the ranges array. Even in our simple case, the YDLidar Driver we use seems to have 720 items, that is ½ degree entries. If you get that wrong your code just won’t work. You can use len(msg.ranges) to figure out the actual number you have.

:h3 Concurrency, threading, race conditions, etc
:source_begin :python
# (1) Don't ever use time.sleep() in a ROS node. It will block the whole operation of ROS, 
# causing other callbacks not to fire and other bad things. instead use either
rospy.sleep(n) # to sleep n seconds

# (2) or
rate = rospy.Rate(h) 
rate.sleep() # to sleep for 1/h seconds - i.e. at a rate of h per second

# (3) Allow ^c to kill your node
while not rospy.is_shutdown():
    # do stuff
    rospy.sleep(0.2)

# (3) If you want your node wait indefinitely for a ^c while allowing callbacks
# Typically make this your last statement executed
rospy.spin()
:source_end

:h3 Package Structure

* Create properly structured packages so they can easily be added to other workspaces.
* Name the directory with the programs `src`
* Other directories should be present only if you use them
* Include a package.xml and CMakeFile.txt (these are tricky, but you have to learn them)
* Use the create_package utility to create a correct package
* It's a good idea to include a readme.md
* It's a good idea to include a license.md

:h3 Launch files
* ... more to come

:h3 Starter Code

* Look at [node_template.py](https://github.com/campusrover/prrexamples/tree/master/src/pa_starters) for a nice general starting template. The prrexamples repo has lots of code for you to look at. *Beware that you should understand what it is that you're using!*

:h3 Sources and references (quality varies a lot!)

* [List of other Best Practices](https://github.com/leggedrobotics/ros_best_practices/wiki)
* [ROS Best Practices](http://wiki.ros.org/Tutorials/Best%20Practices)
* [ROS Patterns](http://wiki.ros.org/ROS/Patterns)
* [More ROS Best Practices](http://wiki.ros.org/BestPractices)
* [Python Code Smells](https://towardsdatascience.com/5-python-code-smells-you-should-be-wary-of-c48cc0eb9d8b)
* [Several Ways of Writing a ROS Node](https://yuzhangbit.github.io/tools/several-ways-of-writing-a-ros-node/)
* [Threading in ROS](https://github.com/m-elwin/me495_threads)