---
title: PA Basic Control
desc: Demonstrate basic control of the robot
slides: true
---
:slide_title Introduction
* This assignment is an will introduce you to creating a basic ROS program
* You will control the robot to do a few autonomous behaviors
* Get practice with publishing to topics
* Get practice with using Timing to affect Robot behaviors

:slide_title Expected preparation

* Python programming, linux shell
* Know the basics of the ROS distributed messaging architecture
* Understand the relationship between time, velocity, and distance
* Understand nodes, topics, publish, subscribe and messages

:slide_title Specific Readings (PRR)

1. pp.26-27 on frames, positions, orientations, and poses;
2. pp.77-80 on mobile platform actuation;
3. pp.85-87 on odometry;
4. pp.92-93 on simulators in general, and pp.95-96 on Gazebo in particular;
5. pp.99-103 on basic mobile platform actuation with the Wander-bot.

:slide_title What skills this assignment covers

* Basic structure of a ros app
* publish and subscribe
* cmd_vel for motion
* odom for odometry
* Run code in Simulation

:slide_title Requirements for the PA

* Drive the robot 50cm out and 180 degree turn in place and try to get back to the same spot
* Drive robot in an exact 30 cm square
* Drive robot in a circle with a radius of 30cm
* Demonstrate this in sim.

:slide_title Steps

* Baseline
  * Note: this PA is done in simuilation
  * Locate the file pa1_starter.py in the cs119_src/ directory
  * Read it and the comments
  * Launch the provided gazebo environment and play with gazebo to get the hang of it
* Drive 1 meter out
  * Consider what it means to drive out 1 meter and stop
  * Use cmd_vel to move the robot forward
  * Collect current position from odom subscription
  * Monitor odom until it tells you that you've gone 1 meter
* 180 degree turn and return
  * How do you use cmd_vel to rotate in place
  * Again use odom, this time to monitor the orientation
  * Rotate until you see 180 degrees ( = 1*math.pi)
  * ...more to come
  

:slide_title What to submit
* Zipped up source code
* url to 120 second youtube video s




â€Œ




* Publish movement commands to a robot in Gazebo simulation
* Use ROS timing to command the robot to move forward X distance and backwards X distance so the robot stops at it's original position (do not worry about robot's final orientation)  
* You can either modify existing code from the prrexamples repo or write your own python ROS node
* The instructions will give you the pieces of code to get you started but the rest will be up to you

### Steps

* Clone the prrexamples repo and copy & paste a ROS node from prrexamples/src/anyfile.py OR create a new python file (for now the directory where you create it doesn't matter but  I would suggest keeping it in prrexamples or another ros package repo)
* The following modules/classes need to be imported. `rospy` provides an interface to the ROS system variables/methods and [Twist](http://docs.ros.org/melodic/api/geometry_msgs/html/msg/Twist.html) is how we represent movement in ROS.


~~~~{.python}
from geometry_msgs.msg import Twist
~~~~

* You will need to publish velocity commands known as `cmd_vel`'s that has a linear and rotational velocity vector components. 
* Do this by creating a publisher object

~~~~{.python}
example_pub = rospy.Publisher('cmd_vel', Twist, queue_size=1)
~~~~
* It is also necessary to declare this python program as a ROS node

~~~~{.python}
rospy.init_node('node_name')
~~~~
* This is all the setup code we need to create a control loop that will loop while the node is still running. 
* Here is an example control loop that publishes a `cmd_vel` to move the robot forward at a constant velocity. 

~~~~{.python}
while not rospy.is_shutdown():
    twist = Twist()
    twist.linear.x = 0.2
    example_pub.publish(twist)
~~~~
* Use `rospy.Time` to get the current time.

~~~~{.python}
starting_time = rospy.Time.now()
~~~~

* This should be enough to get you started and for reference
* The units for `cmd_vel` are `linear=m/s angular=rad/s`

* Launch the gazebo simulator

~~~~{.python}
$ roslaunch turtlebot3_gazebo turtlebot3_empty_world.launch
~~~~

* Navigate to the directory that contains your python ROS node and run

~~~~{.python}
$ rosrun package_name name_of_your_node.py
~~~~

### If you want an extra challenge for a higher grade

* Make your solution more modular by breaking it into separate functions, methods or classes.
* Use odometry to control out and back by distance - 1 meter out, 1 meter back
* Use odometry to drive one meter out but in any direction not just forward and still return back to the starting point
* Instead of out and back, drive four equal segments to form a square and see how close you can come to arriving in the same spot.
* Demonstrate your solution on a real robot

### References and Resources

* Launch gazebo simulation <https://emanual.robotis.com/docs/en/platform/turtlebot3/simulation/>
* Python ROS node reference <http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28python%29>
* Publishing velocity commands <http://wiki.ros.org/turtlesim/Tutorials/Moving%20in%20a%20Straight%20Line>
* How to use ROS time <http://wiki.ros.org/rospy/Overview/Time>

### Submit this through Gradescope

* As always if you "meet" the requirements you would get an 85 +/-
* Each "extra challenge" completed adds an automatic extra points

**Submit your commented Python source code file or files**
|files|

** Submit URL to Video of your program running in gazebo**
[____](url to video)



